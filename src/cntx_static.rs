use std::thread;

pub fn cntx_static () {
    println!("========= 'static в разных контекстах ============");
    /*
    'static в разных контекстах
        Типы: &'static str - строковые литералы
        Trait bounds: T: 'static - владеющие типы
        Потоки: thread::spawn требует F: 'static - замыкание не должно захватывать ссылки с ограниченным временем жизни
    */


    let x = 10;
    thread::spawn(move || {
        println!("{}", x); // i32: 'static (владеющий тип)
    });

    // А так будет ошибка:
    // let y = &x;
    // thread::spawn(move || {
    //     println!("{}", y);
    // });

    /*
    Почему thread::spawn требует 'static:
        Поток может работать дольше, чем текущий стековый фрейм.
        Гарантирует отсутствие висячих ссылок.


    "&'static — это ссылка на глобальные данные (например, строковые литералы). 
    T: 'static означает, что тип либо владеет данными (String, i32), либо содержит только 'static-ссылки."
    */
}


